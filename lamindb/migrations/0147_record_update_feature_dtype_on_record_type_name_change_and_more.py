# Generated by Django 5.2.8 on 2025-11-23 13:31

import pgtrigger.compiler
import pgtrigger.migrations
from django.db import connection, migrations


class Migration(migrations.Migration):
    dependencies = [
        (
            "lamindb",
            "0146_collectionrecord_record_collections_recordcollection_and_more",
        ),
    ]

    operations = []  # type: ignore


if connection.vendor == "postgresql":
    Migration.operations += [
        pgtrigger.migrations.AddTrigger(
            model_name="record",
            trigger=pgtrigger.compiler.Trigger(
                name="update_feature_dtype_on_record_type_name_change",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    condition="WHEN (OLD.name IS DISTINCT FROM NEW.name AND NEW.is_type)",
                    func="WITH RECURSIVE old_record_path AS (\n    -- Start with OLD values directly, don't query the table\n    SELECT\n        OLD.id as id,\n        OLD.name as name,\n        OLD.type_id as type_id,\n        OLD.name::TEXT AS path,\n        1 as depth\n\n    UNION ALL\n\n    SELECT\n        r.id,\n        r.name,\n        r.type_id,\n        r.name || '[' || rp.path AS path,\n        rp.depth + 1\n    FROM lamindb_record r\n    INNER JOIN old_record_path rp ON r.id = rp.type_id\n),\npaths AS (\n    SELECT\n        path as old_path,\n        REPLACE(path, OLD.name, NEW.name) as new_path\n    FROM old_record_path\n    ORDER BY depth DESC\n    LIMIT 1\n)\nUPDATE lamindb_feature\nSET dtype = REPLACE(dtype, paths.old_path, paths.new_path)\nFROM paths\nWHERE dtype LIKE '%cat[Record[%'\n  AND dtype LIKE '%' || paths.old_path || '%';\n\nRETURN NEW;\n",
                    hash="481b2375d6a07c3cbfdbaa86ffee1de95dd92525",
                    operation="UPDATE",
                    pgid="pgtrigger_update_feature_dtype_on_record_type_name_change_28a83",
                    table="lamindb_record",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="record",
            trigger=pgtrigger.compiler.Trigger(
                name="update_feature_dtype_on_record_type_change",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    condition="WHEN (OLD.type_id IS DISTINCT FROM NEW.type_id AND NEW.is_type)",
                    func="WITH RECURSIVE old_record_path AS (\n    SELECT\n        OLD.id as id,\n        OLD.name as name,\n        OLD.type_id as type_id,\n        OLD.name::TEXT AS path,\n        1 as depth\n\n    UNION ALL\n\n    SELECT\n        r.id,\n        r.name,\n        r.type_id,\n        r.name || '[' || rp.path || ']' AS path,\n        rp.depth + 1\n    FROM lamindb_record r\n    INNER JOIN old_record_path rp ON r.id = rp.type_id\n),\nnew_record_path AS (\n    SELECT\n        NEW.id as id,\n        NEW.name as name,\n        NEW.type_id as type_id,\n        NEW.name::TEXT AS path,\n        1 as depth\n\n    UNION ALL\n\n    SELECT\n        r.id,\n        r.name,\n        r.type_id,\n        r.name || '[' || rp.path || ']' AS path,\n        rp.depth + 1\n    FROM lamindb_record r\n    INNER JOIN new_record_path rp ON r.id = rp.type_id\n),\npaths AS (\n    SELECT\n        (SELECT path FROM old_record_path ORDER BY depth DESC LIMIT 1) as old_path,\n        (SELECT path FROM new_record_path ORDER BY depth DESC LIMIT 1) as new_path\n)\nUPDATE lamindb_feature\nSET dtype = REPLACE(dtype, 'cat[Record[' || paths.old_path || ']]', 'cat[Record[' || paths.new_path || ']]')\nFROM paths\nWHERE dtype LIKE '%cat[Record[' || paths.old_path || ']]%';\n\nRETURN NEW;\n",
                    hash="570978a802edc6457352e6ddf85757df31fc90ac",
                    operation="UPDATE",
                    pgid="pgtrigger_update_feature_dtype_on_record_type_change_9f1c8",
                    table="lamindb_record",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="record",
            trigger=pgtrigger.compiler.Trigger(
                name="prevent_record_type_cycle",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    condition="WHEN (NEW.type_id IS NOT NULL)",
                    func="\n                        -- Check for direct self-reference\n                        IF NEW.type_id = NEW.id THEN\n                            RAISE EXCEPTION 'Cannot set type: record cannot be its own type';\n                        END IF;\n\n                        -- Check for cycles in the type chain\n                        IF EXISTS (\n                            WITH RECURSIVE type_chain AS (\n                                SELECT type_id, 1 as depth\n                                FROM lamindb_record\n                                WHERE id = NEW.type_id\n\n                                UNION ALL\n\n                                SELECT r.type_id, tc.depth + 1\n                                FROM lamindb_record r\n                                INNER JOIN type_chain tc ON r.id = tc.type_id\n                                WHERE tc.depth < 100\n                            )\n                            SELECT 1 FROM type_chain WHERE type_id = NEW.id\n                        ) THEN\n                            RAISE EXCEPTION 'Cannot set type: would create a cycle';\n                        END IF;\n\n                        RETURN NEW;\n                    ",
                    hash="deaab832a066dfec76228f5b7a62a08f334876a9",
                    operation="UPDATE OR INSERT",
                    pgid="pgtrigger_prevent_record_type_cycle_56c18",
                    table="lamindb_record",
                    when="BEFORE",
                ),
            ),
        ),
    ]
