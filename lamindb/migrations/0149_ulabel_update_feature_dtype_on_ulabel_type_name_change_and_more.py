# Generated by Django 5.2.8 on 2025-11-30 18:56

import pgtrigger.compiler
import pgtrigger.migrations
from django.db import connection, migrations


class Migration(migrations.Migration):
    dependencies = [
        ("lamindb", "0148_artifact_params_record_params"),
    ]

    operations = []  # type: ignore


if connection.vendor == "postgresql":
    Migration.operations += [
        pgtrigger.migrations.AddTrigger(
            model_name="ulabel",
            trigger=pgtrigger.compiler.Trigger(
                name="update_feature_dtype_on_ulabel_type_name_change",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    condition="WHEN (OLD.name IS DISTINCT FROM NEW.name AND NEW.is_type)",
                    func="WITH RECURSIVE old_ulabel_path AS (\n    -- Start with OLD values directly, don't query the table\n    SELECT\n        OLD.id as id,\n        OLD.name as name,\n        OLD.type_id as type_id,\n        OLD.name::TEXT AS path,\n        1 as depth\n\n    UNION ALL\n\n    SELECT\n        r.id,\n        r.name,\n        r.type_id,\n        r.name || '[' || rp.path AS path,\n        rp.depth + 1\n    FROM lamindb_ulabel r\n    INNER JOIN old_ulabel_path rp ON r.id = rp.type_id\n),\npaths AS (\n    SELECT\n        path as old_path,\n        REPLACE(path, OLD.name, NEW.name) as new_path\n    FROM old_ulabel_path\n    ORDER BY depth DESC\n    LIMIT 1\n)\nUPDATE lamindb_feature\nSET dtype = REPLACE(dtype, paths.old_path, paths.new_path)\nFROM paths\nWHERE dtype LIKE '%cat[ULabel[%'\n  AND dtype LIKE '%' || paths.old_path || '%';\n\nRETURN NEW;\n",
                    hash="44b0610dd7929121f0d6f556b794bc81ee4cc329",
                    operation="UPDATE",
                    pgid="pgtrigger_update_feature_dtype_on_ulabel_type_name_change_dd3db",
                    table="lamindb_ulabel",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="ulabel",
            trigger=pgtrigger.compiler.Trigger(
                name="update_feature_dtype_on_ulabel_type_change",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    condition="WHEN (OLD.type_id IS DISTINCT FROM NEW.type_id AND NEW.is_type)",
                    func="WITH RECURSIVE old_ulabel_path AS (\n    SELECT\n        OLD.id as id,\n        OLD.name as name,\n        OLD.type_id as type_id,\n        OLD.name::TEXT AS path,\n        1 as depth\n\n    UNION ALL\n\n    SELECT\n        r.id,\n        r.name,\n        r.type_id,\n        r.name || '[' || rp.path || ']' AS path,\n        rp.depth + 1\n    FROM lamindb_ulabel r\n    INNER JOIN old_ulabel_path rp ON r.id = rp.type_id\n),\nnew_ulabel_path AS (\n    SELECT\n        NEW.id as id,\n        NEW.name as name,\n        NEW.type_id as type_id,\n        NEW.name::TEXT AS path,\n        1 as depth\n\n    UNION ALL\n\n    SELECT\n        r.id,\n        r.name,\n        r.type_id,\n        r.name || '[' || rp.path || ']' AS path,\n        rp.depth + 1\n    FROM lamindb_ulabel r\n    INNER JOIN new_ulabel_path rp ON r.id = rp.type_id\n),\npaths AS (\n    SELECT\n        (SELECT path FROM old_ulabel_path ORDER BY depth DESC LIMIT 1) as old_path,\n        (SELECT path FROM new_ulabel_path ORDER BY depth DESC LIMIT 1) as new_path\n)\nUPDATE lamindb_feature\nSET dtype = REPLACE(dtype, 'cat[ULabel[' || paths.old_path || ']]', 'cat[ULabel[' || paths.new_path || ']]')\nFROM paths\nWHERE dtype LIKE '%cat[ULabel[' || paths.old_path || ']]%';\n\nRETURN NEW;\n",
                    hash="0ac371a6861b94b3b7ebbfc26f0525071e2dec37",
                    operation="UPDATE",
                    pgid="pgtrigger_update_feature_dtype_on_ulabel_type_change_ae54a",
                    table="lamindb_ulabel",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="ulabel",
            trigger=pgtrigger.compiler.Trigger(
                name="prevent_ulabel_type_cycle",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    condition="WHEN (NEW.type_id IS NOT NULL)",
                    func="\n                        -- Check for direct self-reference\n                        IF NEW.type_id = NEW.id THEN\n                            RAISE EXCEPTION 'Cannot set type: ulabel cannot be its own type';\n                        END IF;\n\n                        -- Check for cycles in the type chain\n                        IF EXISTS (\n                            WITH RECURSIVE type_chain AS (\n                                SELECT type_id, 1 as depth\n                                FROM lamindb_ulabel\n                                WHERE id = NEW.type_id\n\n                                UNION ALL\n\n                                SELECT r.type_id, tc.depth + 1\n                                FROM lamindb_ulabel r\n                                INNER JOIN type_chain tc ON r.id = tc.type_id\n                                WHERE tc.depth < 100\n                            )\n                            SELECT 1 FROM type_chain WHERE type_id = NEW.id\n                        ) THEN\n                            RAISE EXCEPTION 'Cannot set type: would create a cycle';\n                        END IF;\n\n                        RETURN NEW;\n                    ",
                    hash="53487a8e36a64748418457f7229de6d5cf31e6bd",
                    operation="UPDATE OR INSERT",
                    pgid="pgtrigger_prevent_ulabel_type_cycle_863ae",
                    table="lamindb_ulabel",
                    when="BEFORE",
                ),
            ),
        ),
    ]
